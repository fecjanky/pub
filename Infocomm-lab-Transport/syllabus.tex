\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}

\usepackage{url}
\usepackage[]{hyperref}

\usepackage{caption}

\usepackage{listings}

\usepackage{color}
\usepackage[table]{xcolor}

% *** GRAPHICS RELATED PACKAGES ***
%\usepackage[pdftex]{graphicx}
\usepackage{graphicx}
%\usepackage[dvips]{graphicx}
% to place figures on a fixed position
\usepackage{float}

\usepackage{amsmath}

\usepackage[margin=1in]{geometry}

\title{Inspecting High-speed transport protocol simulations}
\author{Sonkoly, Balázs (transzport protocols); Németh,Felicián (Network Simulator);Császár András (Network Simulator)
}
\date{}


\begin{document}

\maketitle

\tableofcontents

\section{Introduction}

\textbf{Transmission Control Protocol (TCP)} has been used for congestion control in the Internet for decades. During
the evolution of the Internet a lot have been changed about the traffic patterns of applications and also in the
structure of the networks. Wireless and high-speed network environments pose new challenges that can be tackled by
current TCP version only at the price of many trade-offs.

TCP -- one of the most important transport protocol of the Internet -- has a history of many decades. The initial
protocol -- that was called \emph{Network Control Protocol - NCP} -- is originated from the '70s. Out of this protocol
had emerged the TCP/IP network's two foundational protocols: IP operating in the network level, and
TCP~\cite{CongestionAvoidance} operating in the transport level. TCP has many features that are required for proving
reliable transport services. Congestion control is one of its main feature that protects the network from
over-utilization. The connection-oriented TCP protocol does closed-loop control during which the transmitter adjusts
its transmission speed based on the incoming acknowledgments affected by the network conditions aimed for having
optimal network utilization and to avoid network breakdown by over-utilization. The initial version was finalized in
\href{http://www.faqs.org/rfcs/rfc793.html}{RFC 793} in 1981. The base mechanism had been extended gradually with new
methods like \textbf{Slow Start}, \textbf{Congestion Avoidance}, RTO calculation, delayed acknowledgment in
1989(\href{http://www.faqs.org/rfcs/rfc1122.html}{RFC 1122}), selective acknowledgment (\textbf{SACK}) in 1996
(\href{http://www.faqs.org/rfcs/rfc2018.html}{RFC 2018}) or definition of \textbf{NewReno} version in 2004
(\href{http://www.faqs.org/rfcs/rfc3782.html}{RFC 3782}).

\section{Conventional TCP: TCP Reno}

TCP's main task is implement congestion control in a distributed, closed-loop system in a way that the users can
utilize the available network bandwidth in an optimal and fair manner. The latter attribute is commonly referred as a
protocol's \textbf{fairness} that is going to be a main aspect in future network's beside efficiency. In case of new
protocols and new control mechanisms -- in contrast with traditional TCP's traditional design methodology -- the
findings and theory of control theory and optimization theory can be utilized during the design phase.

During a TCP connection the transmitting party sends data packets over the network and the receiving side provides
cumulative acknowledgments that informs the sending side about the so far correctly received packets. The TCP
transmitter can send a new packet in case of a received acknowledgment that realizes a from of closed-loop control
(\textbf{self-clocking}). In TCP the congestion control is realized using a sliding-window mechanism where the
transmitter can only have a number of outstanding unacknowledged packets in the network corresponding to the size of
the \textbf{congestion window (cwnd)}. The size of the congestion window is a state variable (beside many others)
controlled by the transmitter entity that can be used for controlling the transmission speed. The main task of the
congestion control algorithm is to control this state variable as a function of the network conditions. TCP Reno
controls this \emph{cwnd} variable differently in different phases of the connection. After connection establishment --
when the network conditions are yet unknown on the network path -- the control of the cwnd and the speed happens using
the \textbf{Slow Start} algorithm. In this phase -- despite the name of the algorithm -- the congestion window expands
exponentially until it reaches a threshold or packet loss occurs. After one of these events the long term behavior is
determined by the \textbf{Congestion Avoidance} phase when the protocol tries to control the transmission speed so that
it won't cause severe congestion in the network. In this phase the congestion window is controlled by the \textbf{AIMD}
(Additive Increase Multiplicative Decrease) mechanism. As a result of this control the congestion window takes on a
typical oscillating, sawtooth pattern.

There are two more mechanisms worth noting here that performs correction of lost packets. These are the \textbf{Fast
    Retransmit} and \textbf{Fast Recovery}. When TCP reno detects multiple ACKs for the same packet (that means the
receiver still expects to receive the same packet) then it implies a packet loss event with not significant congestion
since the subsequent packets have reached the receiver successfully. After 3 duplicate ACKs it retransmits immediately
the missing packet (Fast Retransmit) and transfers into Fast Recovery phase. The transmission does not cease in Fast
Recovery phase, the transmitter can send new packets into the network based on the current value of cwnd and the
received ACKs. As soon as the missing packet has been ACK-ed TCP Reno goes back into Congestion Avoidance. The protocol
differentiates the packet loss due to extreme congestion using a timer that is started after sending each packet. If
this timer expires (RTO, Retransmission Time Out) that means ACKs from the receivers are completely missing or too many
packets have been lost. In such case TCP Reno implies extreme network congestion and restarts in Slow Start. The
different phases of TCP Reno are illustrated on Figure~\ref{fig:TCP-Reno-operation}. Further details can be found
in~\cite{CongestionAvoidance} (can be downloaded from
\href{http://qosip.tmit.bme.hu/cgi-bin/twiki/viewfile/VITT5318/WebHome?rev=1;filename=jacobson88congestion.pdf}{here}).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/tcp-reno.png}
    \caption{The operation and phases of TCP Reno}
    \label{fig:TCP-Reno-operation}
\end{figure}

The properties of AIMD algorithm ensures that the TCP Reno flows transmission speed converges to the fair state in case
of the flows have identical round trip time (RTT). This operation is illustrated by Figure~\ref{fig:AIMD}. Out of the
linear control methods AIMD is capable to provide the convergence to the optimal state from any point in this state
space for providing maximum utilization and fairness. Think about why not MIMD, AIAD and MIAD mechanism are not
convergent!

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/AIMD-trajectory.png}
    \caption{AIMD trajectory in case of two flows with equivalent RTT }
    \label{fig:AIMD}
\end{figure}

The sawtooth pattern originated from the AIMD can be examined on Figure~\ref{fig:sawtooth}. It's clearly visible that
in case of no packet-loss the cwnd grows linearly (additive increase) and when a packet loss occurs the cwnd halves
(multiplicative decrease). This operation is implemented by increasing cwnd by \textbf{cwnd} for each received ACK that
roughly translates to increase by 1 under one RTT. In case of detecting a packet loss the cwnd is halved. The essence
of the method in mathematical format is the following:

\begin{tabular}{ll}
    per-ACK: & $\texttt{cwnd} \leftarrow \texttt{cwnd} + \dfrac{1}{\texttt{cwnd}}$  \\
    per-RTT: & $\texttt{cwnd} \leftarrow \texttt{cwnd} + 1$                         \\
    loss:    & $\texttt{cwnd} \leftarrow \texttt{cwnd} - \dfrac{\texttt{cwnd}}{2}$  \\
\end{tabular}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/sawtooth.png}
    \caption{Sawtooth plot}
    \label{fig:sawtooth}
\end{figure}

The basic TCP reno mechanism is not efficient if multiple packets are lost under one round trip (packet loss burst)
because this can not be corrected efficiently by the Fast Retransmit/Fast Recovery mechanism. For fixing this issue
Selective Acknowledgment had been added (SACK) that can be used by the receiver to inform the transmitter in detail on
which blocks of the packet sequence has been received and which are missing. This naturally involves modifying the
implementation of both the sender and receiver TCP entity. Furthermore the TCP header is extended with a corresponding
optional block (SACK option header). Nowadays most TCP implementations provide the SACK extension.

\section{Congestion control principles}

It has been shown that for TCP Reno the indicator for congestion is a packet loss event that occurs when the queues
overflow on a link with the smallest bandwidth (i.e. the bottleneck link). This method -- called \textbf{packet loss
    based} congestion control -- is present in several new, high-speed TCP version however it has some drawbacks as well.
The actual congestion control is can be carried in 1 bit of information (packet loss/no packet loss) as a consequence
it does not allow fine-grained or sophisticated control algorithms to be used. Furthermore packet-loss based control
involves filling up queues since the control action is only carried out in case of a packet loss. That infers the
presence of oscillation that incurs  system wide stability issues. Another control approach is to measure the RTT of
individual packets and control the transmission speed based on this input. These \textbf{delay-based} methods aims for
a single TCP flow keeping a given amount of packets in the network queues along the network path. These protocols
estimate the components of RTT using a certain method. The components are the physical propagation time and the queuing
time. In these type of algorithms the latter one is subject to be controlled by different methods.
The newest methods combine the packet loss and delay-based methods into a \textbf{hybrid} algorithm for congestion
control where the transmitter reacts to both packet loss and change in delay events. Even more sophisticated methods
are applied by some protocols that utilize \textbf{passive or active measurement methods} for estimating the available
network bandwidth and performing control.

In the previously described methods the transmitter has the necessary logic  and the concrete algorithms can be
improved flexibly or even replaced completely without changing other parts of the network. However there is a concept
that the current state of the network congestion is reported by the network routers explicitly to the transmitter.
These \textbf{explicit congestion signaling} methods requires modification of existing network routers.

\section{High-Speed TCP versions}
\begin{table}
    \begin{tabular}{|p{0.25\textwidth}|p{0.25\textwidth}|p{0.25\textwidth}|p{0.25\textwidth}|}\hline
        \cellcolor{blue!25}protocol                                                   & \cellcolor{blue!25}type                & \cellcolor{blue!25}suggested by,when                                   &
        \cellcolor{blue!25}properties                                                                                                                                                                                         \\\hline
        \cellcolor{blue!25}HighSpeed TCP                                              & packet loss based                      & S. Floyd, International Computer Science Institute (ICSI),
        Berkeley University of California, 2003.                                      & AIMD                                                                                                                                  \\\hline
        \cellcolor{blue!25}Scalable TCP                                               & packet loss based                      & T. Kelly, CERN \& University of Cambridge, 2003.                       & MIMD                \\\hline
        \cellcolor{blue!25}BIC TCP/CUBIC                                              & packet loss based                      & I. Rhee et al., Networking Research Lab, North Carolina State
        University, 2004-2005.                                                        & Good utilization,fairness \& stability                                                                                                \\\hline
        \cellcolor{blue!25}FAST TCP                                                   & delay-based                            & S. Low et al., Netlab, California Institute of Technology, 2004. (now:
        FastSoft Inc.)                                                                & promising fairness properties                                                                                                         \\\hline
        \cellcolor{blue!25}TCP Westwood                                               & measurement based                      & M.Y. Sanadidi, M. Gerla et al., High Performance Internet Lab,
        Network Research Lab, University of California, Los Angeles (UCLA), 2001-2005 & multiple variants, different
        approximation methods                                                                                                                                                                                                 \\\hline
        \cellcolor{blue!25}Compound TCP                                               & hybrid                                 & K. Tan et al., Microsoft Research, 2005.                               & AIMD + delay-based
        component                                                                                                                                                                                                             \\\hline
        \cellcolor{blue!25}XCP                                                        & explicit congestion signaling          & D. Katabi et al., Massachusetts Institute of Technology (MIT),
        2002.                                                                         & change in network routers required                                                                                                    \\\hline
    \end{tabular}
    \caption{Overview High-Speed TCP versions}
    \label{table:tcpver}
\end{table}

In the following there will be brief overview of the more important protocols and their potential future role.
Table~\ref{table:tcpver} has a compact summary on this topic while a more detailed version can be found
in~\cite{TCPFairnessAnalysis}. Firstly the more significant packet loss based variants are introduced. One of the first
high-speed TCP version was \textbf{HighSpeed TCP}~\cite{HighSpeedTCP} that uses AIMD with a simple modification. This
protocol becomes more adaptive because it changes the conventionally static parameters of AIMD dynamically based on the
size of the congestion window. This results in more aggressive increase of cwnd in large-scale high-speed networks
while also resulting in milder throttling. The concrete operation can be formalized as:

\begin{tabular}{ll}
    per-ACK: & $\texttt{cwnd} \leftarrow \texttt{cwnd} + \dfrac{a(\texttt{cwnd})}{\texttt{cwnd}}$  \\
    loss:    & $\texttt{cwnd} \leftarrow \texttt{cwnd} - b(\texttt{cwnd})\texttt{cwnd}$            \\
\end{tabular}

It can be shown that this is a generalization of TCP Reno with $\texttt{a(cwnd)}=1$ and $\texttt{b(cwnd)}=0.5$
constants. Figure~\ref{fig:HSvsReno} compares the dynamics of the congestion window between TCP Reno and HighSpeedTCP.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/HSTCP.png}
    \caption{Dynamics of HighSpeedTCP (HSTCP) vs. TCP Reno (REGTCP)}
    \label{fig:HSvsReno}
\end{figure}

Another early implementation is \textbf{Scalable TCP}~\cite{ScalableTCP} where scalability is provided through
\textbf{MIMD} mechanism. In this variant the Congestion Avoidance phase  -- that determines the long term behavior --
utilizes a multiplicative increase similarly to Slow Start algorithm (with less aggressive parameters) instead of the
conventional additive increase. The future application of Scalable TCP is questionable due to severe problems with
fairness properties~\cite{TCPFairnessAnalysis}. The congestion window control can be formulated as:

\begin{tabular}{ll}
    per-ACK: & $\texttt{cwnd} \leftarrow \texttt{cwnd} + a$       \\
    loss:    & $\texttt{w} \leftarrow \texttt{w} - b \texttt{w}$  \\
\end{tabular}

The creators of the protocol suggest the values $\texttt{a}=0.001$ and $\texttt{b}=0.125$~\cite{ScalableTCP}. The main
differences between TCP Reno and Scalable TCP are shown on Figure~\ref{fig:ScalableVSReno}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/ScalableTCP.png}
    \caption{Comparison of Scalable TCP and TCP Reno}
    \label{fig:ScalableVSReno}
\end{figure}

The conventional AIMD can not provide fair operation in case when flows have significantly different round trip time.
This so-called RTT unfairness problem is addressed by \textbf{BIC TCP}~\cite{BICTCP} and its successor
\textbf{CUBIC}~\cite{CUBIC}. The BIC TCP utilizes a combination of an additive increase and a binary search based
method with other procedures increasing fairness. CUBIC aims for providing same operating characteristics using way
simple control mechanism where the congestion window is controlled using a cubic function in contrast with the
previously utilized linear, logarithmic and exponential sections. It is worth to note the starting from version 2.6.8
Linux kernel uses BIC TCP as default while starting from 2.6.19 CUBIC is the default TCP implementation. Currently
CUBIC is the default TCP implementation of Linux based systems therefore it has a significant role in today's network
traffic.

Figure~\ref{fig:bictcp} illustrates a period of BIC TCP congestion window adjustment phases. The curve seen on this
figure is hard to express in analytical form and CUBIC approximate this using cubic polynomial functions that results
in similarly good operation characteristics.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/BICTCP.png}
    \caption{A period of BIC TCP congestion windows adjustment}
    \label{fig:bictcp}
\end{figure}

There has been significant proceedings in delay-based congestion control with several protocol recommendations.
Delay-based control first appeared in TCP Vegas protocol. This has been superseded by \textbf{FAST TCP}~\cite{FastTCP}
that is a modified version of TCP Vegas adapted to high speed environments. THe control happens based on the previously
described principles. The protocol tries to keep the number of queued packets between two configured boundary values.
Selecting and tuning these boundary values are not an easy task. FAST TCP protocol with appropriate settings shows
promising results in terms of both network utilization and fairness~\cite{TCPFairnessAnalysis}. The operation
characteristics --that are fundamentally different compared to the previously introduced ones-- are shown on
Figure~\ref{fig:FastTCP}. This has been created using a network setting where one FAST TCP flow is forwarded on the
bottleneck link and the dynamics of the queue and the FAST TCP congestion window size have been captured. It's clearly
visible that after a transient phase the congestion windows size stabilizes on a constant value that is able to keep
the queue utilization approximately constant. This eliminates the unwanted oscillation.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/FAST.png}
    \caption{FAST TCP dynamics}
    \label{fig:FastTCP}
\end{figure}

The current TCP recommendations combine the packet loss and delay-based principles based on various algorithms. Several
methods have been published and implemented out of which the most notable is \textbf{Compound TCP}~\cite{CompundTCP}.
This version has been developed by Microsoft Research employees and is used as a default implementation in Windows
Vista and Windows Server 2008 OSs. Furthermore it is available as a hotfix for other Windows version and also a Linux
based implementation has been created as well. The essence of the protocol that it keeps two congestion window state
variables: a conventional AIMD controlled one and another delay-based controlled. The current size of the congestion
window is the sum of these two components. Based on different network conditions the protocol controls the two
variables using different methods in a way that the resulting behavior provides efficient network utilization and fair
inter-operation with conventional TCP protocol implementations.

\textbf{TCP Westwood}~\cite{TCPWestwood} is one of the TCP implementations with bandwidth approximation based
congestion control that has several variants available. Several approximation procedures have been developed,
implemented and tested over the years that were incorporated in different variants of the protocol.

Finally it has to be noted that there is \textbf{XCP}~\cite{XCP} that is based on explicit signaling of congestion and
therefore requires modified network architecture. In this variant the routers notify the transmitter explicitly about
the level of congestion and can also signal the available bandwidth. In this method the control of utilization and
fairness can be separated clearly. A significant drawback of the protocol is that it requires modification of the
network routers.

One can not foretell that which will be the dominant high speed TCP variant out of the few existing implementations
presented here. Currently this is an active field of research and development in many dominant research facilities all
over the globe. Even comparison of the recommendations is non-trivial since there are no standardized aspects, metrics,
network environments and measurements methods that can provide adequate answers on which protocol is the best or
optimal under given conditions.

\section{Introduction to Network Simulator}

\subsection{Introduction}

\emph{Network Simulator} is a discrete, event-driven, packet based network simulator that is supported by many universities and research institutes and also it is open-source (\url{http://www.isi.edu/nsnam}). Using this program beside many things it is possible to inspect routing protocols, multicast and TCP protocols even using wireless networks.

\textbf{ns} was developed in C++ and otcl languages. The core of the simulator, the protocol implementations and the computation intensive code was written in C++. In contrast octl script language was used for providing the simulation configuration and for solutions of one-time tasks that do not require performance.

The class hierarchy of the system is well designed. New functionality can be easily added in C++ to the existing system, but that is out of scope on this lab. The aim of this class to get a grip on the basics of the otcl interface and to discover some simple network simulation based measurement methods.

The ns program can be viewed as a tcl interpreter with object-oriented extensions from where the class hierarchy that supports network simulation is reachable.

As a first step of the simulation an (o)tcl script has to be created that defines the network components, the interconnection between those components furthermore the timing of the scripted events (e.g. the transmission start time of a data source). The ns program has to be launched with the script as argument (e.g. \textbf{ns program.tcl}) that produces the log entries and simulation results in output files. During post-processing the simulation result can be processed using \textbf{awk,perl,gnuplot,excel,etc.} programs. For visual inspection of the results \textbf{nam} program can be used (NAM - Network Animator) can be used with a log file in special format. This program graphically visualizes the route of certain packets in the network.

\subsection{Further Reading}\label{sec:tcl}
\begin{itemize}
  \item \href{https://www.tcl.tk/man/tcl8.5/tutorial/tcltutorial.html}{TCL Tutorial}
  \item \href{https://www.isi.edu/nsnam/otcl/doc/tutorial.html}{OTcl tutorial}
  \item \href{http://www.isi.edu/nsnam/ns/ns-documentation.html}{ns manual}
  \item \href{http://alpha.tmit.bme.hu/meresek/tcl2.pdf}{TCL command reference}
\end{itemize}

\subsection{Tcl basics}

Tcl provides rapid prototyping in ns system. In this section a brief overview of the language is given that provides adequate level of knowledge for completing these measurements.

Commands of a Tcl scipt are separated either by a semi-colon or by a new line. Commands are made of one or more words where the firs word is the name of the command and optionally the following words are arguments to the command. Words are separated by space or tab characters.

When evaluating a command the interpreter breaks the commands into words and performs potential replacements then executes the command with the given arguments. \verb!$variable! is replaced by the value of the variable while \verb!command! is replaced by the return value of the command. Variables don't have type all value is stored as string.

Please read the Tcl related materials under Section~\ref{sec:tcl} that are required for successful completion of the measurements. The program fragment in listing~\ref{lst:10faktorial} calculating the factorial value of 10 contains some basic language constructs of Tcl.

\begin{lstlisting}[
language=tcl,
captionpos=b,
caption={Tcl program calculating the value of 10!},
label={lst:10faktorial}]
  1:  set fact 1
  2:  for {set i 1} {$i <= 10} {incr i} {
  3:      set fact [expr $fact*$i]
  4:  }
  5:  puts $fact
\end{lstlisting}

In the first line variable \verb!fact! is given the value 1 using the \verb!set!. In the second line a for loop is started similarly to the C programming language where the braces prevent substitution while decomposing the command into words. The use of square brackets are illustrated on line 3 where the \verb!expr! calculates a numeric value and the result of the expression will be stored in the new value of \verb!fact! -- after executing the \verb!set! command. Finally the result is written to the output using the \verb!puts! command on the last line.

A recursive way of calculating factorial is show in program listing~\ref{lst:factorial}.

\begin{lstlisting}[
language=tcl,
captionpos=b,
caption={Tcl program for calculating the factorial value of a number},
label={lst:factorial}]
  0:  proc factorial num {
  1:      if {$num > 0} {
  2:          return [expr $num*[factorial [expr $num-1]]]
  3:      } else {
  4:          return 1
  5:      }
  6:  }
  7:  puts [factorial 10]
\end{lstlisting}

\subsection{Otcl basics}


\appendix

\section{Entry quiz sample questions}

\begin{enumerate}
    \item Describe briefly the main concept of the OpenFlow recommendation.
    \item What are the components of an OpenFlow network?
\end{enumerate}

\section{Lab exercises}

\subsection{Lab environment}

\end{document}